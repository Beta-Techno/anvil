understand the flake repo 100% please
You said:
for ubuntu I know  I can integrate with the flake but I also have this workflow to set up ubuntu without nix at all

Legacy Setup
This guide installs and configures a development workstation on Ubuntu the classic way—using apt, vendor .deb packages downloaded from websites, and a few helper scripts. Use this if you prefer or require a non‑Nix workflow.

What you'll get
System fully updated with drivers
Core development tools (Git, VS Code, Chrome)
Language runtimes and package managers
Docker & Compose
Enhanced terminal environment
Optional: media/codecs, Flatpak/Snap
0) Prerequisites
– Ubuntu 24.04 LTS freshly installed and booted – Sudo access on your user – Reliable Internet connection (wired preferred for drivers)

1) System Foundation
#!/usr/bin/env bash
set -euo pipefail

# Update system
sudo apt update
sudo apt -y dist-upgrade

# Essential system packages
sudo apt install -y \
  build-essential \
  ca-certificates \
  curl \
  wget \
  git \
  gnupg \
  software-properties-common \
  unzip \
  ripgrep \
  fzf \
  htop \
  net-tools \
  tmux

# Enable community codecs (optional)
sudo apt install -y ubuntu-restricted-extras || true

# Drivers
sudo ubuntu-drivers autoinstall || true
sudo apt install -y bcmwl-kernel-source || true

echo "[OK] System foundation complete. Reboot if kernel was upgraded."

2) Languages & Package Managers
#!/usr/bin/env bash
set -euo pipefail

# Node.js via nvm
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
nvm install --lts
nvm use --lts
nvm alias default 'lts/*'

# Python via pyenv
# Required build dependencies for CPython
sudo apt install -y \
  build-essential libssl-dev zlib1g-dev \
  libbz2-dev libreadline-dev libsqlite3-dev \
  libffi-dev liblzma-dev tk-dev
curl https://pyenv.run | bash
export PYENV_ROOT="$HOME/.pyenv"
export PATH="$PYENV_ROOT/bin:$PATH"
eval "$(pyenv init -)"
pyenv install 3.11.0
pyenv global 3.11.0

# Ruby via rbenv
sudo apt install -y rbenv ruby-build
rbenv install 3.1.0
rbenv global 3.1.0

# Go
wget https://go.dev/dl/go1.21.0.linux-amd64.tar.gz
sudo tar -C /usr/local -xzf go1.21.0.linux-amd64.tar.gz
echo 'export PATH=$PATH:/usr/local/go/bin' >> ~/.bashrc

# Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
source ~/.cargo/env

# Java
sudo apt install -y default-jdk

echo "[OK] Language runtimes and package managers installed."

3) Tailscale VPN Service
#!/usr/bin/env bash
# Tailscale — Ubuntu 24.04+ base install only (apt repo + package)
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive

# Detect Ubuntu codename (e.g., noble)
if [[ -r /etc/os-release ]]; then
  . /etc/os-release
  CODENAME="${VERSION_CODENAME:-}"
fi
: "${CODENAME:=$(lsb_release -cs 2>/dev/null || echo noble)}"

# Add keyring and apt source
sudo mkdir -p --mode=0755 /usr/share/keyrings
curl -fsSL "https://pkgs.tailscale.com/stable/ubuntu/${CODENAME}.noarmor.gpg" \
  | sudo tee /usr/share/keyrings/tailscale-archive-keyring.gpg >/dev/null
curl -fsSL "https://pkgs.tailscale.com/stable/ubuntu/${CODENAME}.tailscale-keyring.list" \
  | sudo tee /etc/apt/sources.list.d/tailscale.list >/dev/null

# Install package (no service enable, no login)
sudo apt-get update -y
sudo apt-get install -y tailscale

# Verify installed version
tailscale version || true

echo "[OK] Tailscale installed. No service start or auth performed."
# Next steps (elsewhere): sudo systemctl enable --now tailscaled ; sudo tailscale up

4) Git & SSH
#!/usr/bin/env bash
# Git & SSH — prompt for name/email only; idempotent; Ubuntu 24.04
set -euo pipefail

# Preflight (assumes System Foundation already ran)
command -v git >/dev/null      || { echo "git not found; run System Foundation first."; exit 1; }
command -v ssh-keygen >/dev/null || { echo "openssh-client not found; run System Foundation first."; exit 1; }

# Helpers
git_get() { git config --global --get "$1" 2>/dev/null || true; }

# Current values (used as defaults in prompts)
current_name="$(git_get user.name)"
current_email="$(git_get user.email)"

# Prompt for identity (only two prompts)
read -r -p "Full name [${current_name}]: " name_input || true
read -r -p "Email [${current_email}]: "     email_input || true
name="${name_input:-$current_name}"
email="${email_input:-$current_email}"

if [[ -z "$name" || -z "$email" ]]; then
  echo "Name and email are required. Aborting."
  exit 1
fi

# Git config (sane defaults; safe to re-run)
git config --global user.name "$name"
git config --global user.email "$email"
git config --global init.defaultBranch main
git config --global pull.ff only
git config --global color.ui auto

# SSH keypair (Ed25519 with strong KDF; no passphrase prompt)
umask 077
mkdir -p "$HOME/.ssh"; chmod 700 "$HOME/.ssh"
key="$HOME/.ssh/id_ed25519"
if [[ ! -f "$key" ]]; then
  ssh-keygen -t ed25519 -a 100 -C "$email" -f "$key" -N ""
fi
chmod 600 "$key"
chmod 644 "${key}.pub"

# Minimal host stanza for GitHub (no prompts; noop if already present)
cfg="$HOME/.ssh/config"; touch "$cfg"; chmod 600 "$cfg"
if ! grep -qE '^[[:space:]]*Host[[:space:]]+github\.com(\s|$)' "$cfg"; then
  {
    echo ""
    echo "Host github.com"
    echo "  HostName github.com"
    echo "  User git"
    echo "  IdentityFile $key"
    echo "  IdentitiesOnly yes"
    echo "  AddKeysToAgent yes"
  } >> "$cfg"
fi

# Optional: enable SSH commit signing if Git >= 2.34 (doesn't enforce signing)
if git version | awk '{print $3}' | awk -F. '{exit !($1>2 || ($1==2 && $2>=34))}'; then
  git config --global gpg.format ssh
  git config --global user.signingkey "${key}.pub"
fi

# Output
echo "Public key (${key}.pub):"
cat "${key}.pub"
echo
echo "Add this key to your Git hosting, then test: ssh -T git@github.com || true"


5) Neo / LazyVim IDE
#!/usr/bin/env bash
set -euo pipefail

echo "==> LazyVim bootstrap for Ubuntu 24.04 (Noble)"
echo "==> This will install deps, Neovim (AppImage), Node (nvm), pipx+pynvim, and LazyVim starter."

# Sanity: run as regular user
if [[ $EUID -eq 0 ]]; then
  echo "Please run as a regular user (not root). The script will use sudo when needed."
  exit 1
fi

BASHRC="$HOME/.bashrc"
ZSHRC="$HOME/.zshrc"
ensure_path_line='export PATH="$HOME/.local/bin:$PATH"'

# Deps: fd, ripgrep, fzf, xclip, pipx
export DEBIAN_FRONTEND=noninteractive
sudo apt update
sudo apt install -y curl git unzip ca-certificates build-essential ripgrep fd-find fzf xclip python3-venv pipx

# fd as 'fd'
mkdir -p "$HOME/.local/bin"
if command -v fdfind >/dev/null 2>&1; then
  ln -sf "$(command -v fdfind)" "$HOME/.local/bin/fd"
fi

# Ensure ~/.local/bin on PATH
grep -qF "$ensure_path_line" "$BASHRC" || echo "$ensure_path_line" >> "$BASHRC"
[[ -f "$ZSHRC" ]] && (grep -qF "$ensure_path_line" "$ZSHRC" || echo "$ensure_path_line" >> "$ZSHRC")
export PATH="$HOME/.local/bin:$PATH"

# Neovim (x86_64 AppImage)
tmpd="$(mktemp -d)"; pushd "$tmpd" >/dev/null
curl -LO https://github.com/neovim/neovim/releases/latest/download/nvim-linux-x86_64.appimage
chmod +x nvim-linux-x86_64.appimage
sudo mv nvim-linux-x86_64.appimage /usr/local/bin/nvim
popd >/dev/null; rm -rf "$tmpd"

# Node provider via nvm (already installed above)
export NVM_DIR="$HOME/.nvm"; [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
nvm use --lts || nvm install --lts
npm install -g neovim

# Python provider via pipx (PEP-668 friendly)
pipx ensurepath || true
pipx install --python python3 pynvim || pipx upgrade pynvim
PY_HOST="$HOME/.local/pipx/venvs/pynvim/bin/python3"

# LazyVim starter
cfg="$HOME/.config/nvim"; share="$HOME/.local/share/nvim"
ts="$(date +%F-%H%M%S)"
[[ -d "$cfg" ]] && mv "$cfg" "${cfg}.bak-${ts}"
[[ -d "$share" ]] && mv "$share" "${share}.bak-${ts}"

git clone https://github.com/LazyVim/starter "$cfg"
rm -rf "$cfg/.git"

# Set python host
mkdir -p "$cfg/lua/config"
cat > "$cfg/lua/config/providers.lua" <<EOF
-- Prefer pipx's pynvim if available
local host = vim.fn.expand("$PY_HOST")
if vim.fn.executable(host) == 1 then
  vim.g.python3_host_prog = host
end
EOF

# Optional extras placeholder
mkdir -p "$cfg/lua/plugins"
cat > "$cfg/lua/plugins/extras.lua" <<'EOF'
return {
  -- { import = "lazyvim.plugins.extras.lang.typescript" },
  -- { import = "lazyvim.plugins.extras.lang.python" },
  -- { import = "lazyvim.plugins.extras.coding.copilot" },
}
EOF

# Pre-bootstrap plugins headlessly (best effort)
set +e
nvim --headless "+Lazy! sync" "+qa"
set -e

nvim --version | head -n1

echo "✅ LazyVim ready. Run: nvim"


6) Alacritty Terminal
#!/usr/bin/env bash
# Alacritty from-source one-shot installer for Ubuntu (fresh ISO friendly)
# - Installs build deps & rustup
# - Clones Alacritty, builds release
# - Installs binary, icon, desktop entry (with absolute Exec/TryExec)
# - Installs man page, terminfo, and shell completions (bash/zsh/fish)

set -euo pipefail

# ---------- config ----------
REPO_URL="https://github.com/alacritty/alacritty.git"
REPO_DIR="$HOME/alacritty"
BIN_DST="/usr/local/bin/alacritty"
ICON_SRC_NAME="alacritty-term.svg"
ICON_DST="/usr/share/pixmaps/Alacritty.svg"
DESKTOP_SRC="extra/linux/Alacritty.desktop"
MAN_DST_DIR="/usr/local/share/man/man1"
BASH_COMPLETION_DIR="$HOME/.bash_completion.d"
ZSH_COMPLETION_DIR="${ZDOTDIR:-$HOME}/.zsh/completions"
FISH_COMPLETION_DIR="$HOME/.config/fish/completions"

log() { printf "\n\033[1;32m[%s]\033[0m %s\n" "$(date +%H:%M:%S)" "$*"; }
warn() { printf "\n\033[1;33m[warn]\033[0m %s\n" "$*"; }
die() { printf "\n\033[1;31m[err]\033[0m %s\n" "$*"; exit 1; }

require_sudo() {
  if [[ $EUID -ne 0 ]]; then
    if ! command -v sudo >/dev/null 2>&1; then
      die "This script needs root privileges and 'sudo' is not available."
    fi
  fi
}

apt_install() {
  log "Installing packages via apt…"
  sudo apt update
  sudo apt install -y \
    git curl build-essential cmake pkg-config python3 \
    desktop-file-utils gzip ncurses-bin \
    libfreetype6-dev libfontconfig1-dev libxcb-xfixes0-dev \
    libxkbcommon-dev libwayland-dev wayland-protocols \
    libegl1-mesa-dev
}

install_rustup() {
  if command -v cargo >/dev/null 2>&1; then
    log "Rust/Cargo already present: $(cargo -V)"
    return
  fi
  log "Installing rustup (Rust toolchain manager)…"
  curl -fsSL https://sh.rustup.rs | sh -s -- -y
  # shellcheck disable=SC1091
  source "$HOME/.cargo/env"
  rustup override set stable || true
  rustup update stable
  log "Rust installed: $(rustc -V); cargo: $(cargo -V)"
}

clone_or_update_repo() {
  if [[ -d "$REPO_DIR/.git" ]]; then
    log "Repo exists, pulling latest…"
    git -C "$REPO_DIR" fetch --all --tags
    git -C "$REPO_DIR" pull --ff-only
  else
    log "Cloning Alacritty repo…"
    git clone "$REPO_URL" "$REPO_DIR"
  fi
}

build_release() {
  log "Building Alacritty in release mode…"
  # ensure cargo is in PATH for this shell
  # shellcheck disable=SC1091
  [[ -f "$HOME/.cargo/env" ]] && source "$HOME/.cargo/env"
  pushd "$REPO_DIR" >/dev/null
  cargo build --release
  popd >/dev/null
}

install_binary_icon_desktop() {
  log "Installing binary → $BIN_DST"
  sudo install -Dm755 "$REPO_DIR/target/release/alacritty" "$BIN_DST"

  log "Installing icon → $ICON_DST"
  sudo install -Dm644 "$REPO_DIR/extra/logo/$ICON_SRC_NAME" "$ICON_DST"

  if [[ ! -f "$REPO_DIR/$DESKTOP_SRC" ]]; then
    die "Desktop file not found at $REPO_DIR/$DESKTOP_SRC"
  fi

  log "Installing desktop entry with absolute Exec/TryExec…"
  # Use absolute path so desktops that ignore /usr/local/bin in PATH still find it
  sudo desktop-file-install \
    --set-key=Exec --set-value="$BIN_DST %F" \
    --set-key=TryExec --set-value="$BIN_DST" \
    "$REPO_DIR/$DESKTOP_SRC"

  sudo update-desktop-database || true
}

install_manpage() {
  log "Installing man page → $MAN_DST_DIR/alacritty.1.gz"
  sudo mkdir -p "$MAN_DST_DIR"
  gzip -c "$REPO_DIR/extra/alacritty.man" | sudo tee "$MAN_DST_DIR/alacritty.1.gz" >/dev/null || true
  # Refresh man-db quietly (won’t fail the script if unavailable)
  if command -v mandb >/dev/null 2>&1; then
    sudo mandb -q || true
  fi
}

install_terminfo() {
  log "Installing terminfo entries (alacritty & alacritty-direct)…"
  # Install system-wide (needs root)
  sudo tic -xe alacritty,alacritty-direct "$REPO_DIR/extra/alacritty.info" || true
}

install_shell_completions() {
  log "Installing shell completions (bash/zsh/fish if present)…"

  # bash
  if command -v bash >/dev/null 2>&1; then
    mkdir -p "$BASH_COMPLETION_DIR"
    cp "$REPO_DIR/extra/completions/alacritty.bash" "$BASH_COMPLETION_DIR/alacritty"
    if ! grep -q 'BASH_COMPLETION_DIR' "$HOME/.bashrc" 2>/dev/null; then
      {
        echo ""
        echo "# Alacritty completion"
        echo "if [ -f \"$BASH_COMPLETION_DIR/alacritty\" ]; then"
        echo "  source \"$BASH_COMPLETION_DIR/alacritty\""
        echo "fi"
      } >> "$HOME/.bashrc"
    fi
  fi

  # zsh
  if command -v zsh >/dev/null 2>&1; then
    mkdir -p "$ZSH_COMPLETION_DIR"
    cp "$REPO_DIR/extra/completions/_alacritty" "$ZSH_COMPLETION_DIR/_alacritty"
    # Ensure fpath has our completions and compinit runs
    if ! grep -q '\.zsh/completions' "${ZDOTDIR:-$HOME}/.zshrc" 2>/dev/null; then
      {
        echo ""
        echo "# Alacritty completion"
        echo "fpath+=$ZSH_COMPLETION_DIR"
        echo "autoload -Uz compinit"
        echo "compinit"
      } >> "${ZDOTDIR:-$HOME}/.zshrc"
    fi
  fi

  # fish
  if command -v fish >/dev/null 2>&1; then
    mkdir -p "$FISH_COMPLETION_DIR"
    cp "$REPO_DIR/extra/completions/alacritty.fish" "$FISH_COMPLETION_DIR/alacritty.fish"
  fi
}

optional_set_default_terminal() {
  # Register with update-alternatives but DO NOT force as default automatically.
  if command -v update-alternatives >/dev/null 2>&1; then
    log "Registering Alacritty with update-alternatives (not setting as default)…"
    sudo update-alternatives --install /usr/bin/x-terminal-emulator x-terminal-emulator "$BIN_DST" 50 || true
    warn "If you want Alacritty as the default terminal later, run:\n      sudo update-alternatives --config x-terminal-emulator"
  fi
}

ensure_config_file() {
  # Create a minimal starter config only if none exists
  local confdir="$HOME/.config/alacritty"
  local conffile="$confdir/alacritty.toml"
  if [[ ! -f "$conffile" ]]; then
    log "Creating a minimal ~/.config/alacritty/alacritty.toml"
    mkdir -p "$confdir"
    cat > "$conffile" <<'EOF'
# Minimal Alacritty config (created by installer)
[window]
# padding.x = 4
# padding.y = 4

[font]
# normal.family = "JetBrainsMono Nerd Font"
size = 12.0

[scrolling]
history = 10000
EOF
  fi
}

post_checks() {
  log "Verifying installation…"
  if ! command -v "$BIN_DST" >/dev/null 2>&1; then
    die "Alacritty binary not found at $BIN_DST"
  fi
  "$BIN_DST" --version || true
  log "Done. You may need to open a new shell for completions to load."
}

main() {
  require_sudo
  apt_install
  install_rustup
  clone_or_update_repo
  build_release
  install_binary_icon_desktop
  install_manpage
  install_terminfo
  install_shell_completions
  optional_set_default_terminal
  ensure_config_file
  post_checks
  log "Alacritty is ready. Launch it from your app menu or run: alacritty"
}

main "$@"


7) Ghostty Terminal
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/mkasberg/ghostty-ubuntu/HEAD/install.sh)"


8) Zed IDE
curl -f https://zed.dev/install.sh | sh

9) Cursor IDE
#!/bin/bash

set -euo pipefail

# Prevent interactive prompts that can cause hangs
export DEBIAN_FRONTEND=noninteractive
export DEBIAN_PRIORITY=critical
export NEEDRESTART_MODE=a

# Pre-configure debconf to prevent any interactive questions
# This prevents popup windows from appearing
echo 'debconf debconf/frontend select Noninteractive' | sudo debconf-set-selections 2>/dev/null || true

echo "[1/5] apt prep"

sudo -E apt update
sudo -E apt install -y curl ca-certificates

echo "[2/5] detect arch"

arch="$(dpkg --print-architecture)"   # amd64 or arm64
case "$arch" in
  amd64|arm64) ;;
  *) echo "Unsupported arch: $arch" >&2; exit 1 ;;
esac

echo "[3/5] resolve latest .deb URL from cursor.com"

page="$(curl -fsSL https://cursor.com/download)"

# Extract all candidate .deb links from the page (robust to domain/path changes)
# - We look for any https://... .deb link, then filter by architecture tokens.
set +e
candidates="$(printf '%s' "$page" \
  | grep -Eo 'https://[^"]+\.deb')"
rc=$?
set -e

if [ $rc -ne 0 ] || [ -z "${candidates:-}" ]; then
  echo "Could not scrape any .deb links from the page." >&2
  echo "Open https://cursor.com/download and grab the Linux .deb manually." >&2
  exit 2
fi

# Map Debian arch -> common tokens used in filenames
case "$arch" in
  amd64)  tok='(amd64|x64|x86_64)' ;;
  arm64)  tok='(arm64|aarch64)'    ;;
esac

set +e
url="$(printf '%s\n' "$candidates" | grep -Ei "$tok" | head -n1)"
set -e

if [ -z "${url:-}" ]; then
  echo "Found .deb links, but none matched arch=$arch ($tok)." >&2
  echo "Links were:" >&2
  printf '  %s\n' $candidates >&2
  exit 3
fi

echo "Found: $url"

echo "[4/5] download"

tmpdir="$(mktemp -d)"
cd "$tmpdir"
trap "cd / && rm -rf '$tmpdir'" EXIT

curl -fLo cursor.deb "$url"
chmod 644 cursor.deb   # silence _apt sandbox warning

echo "[5/5] install"

# Use apt to resolve any dependencies automatically
# -E preserves environment variables (DEBIAN_FRONTEND)
# This ensures no interactive prompts can appear
sudo -E apt install -y \
  -o Dpkg::Options::="--force-confdef" \
  -o Dpkg::Options::="--force-confold" \
  ./cursor.deb

echo "✅ Cursor installed. Launch from app menu or: cursor &"


10) Chrome Web Browser
#!/usr/bin/env bash
set -euo pipefail

# Google Chrome via official apt repository (auto-updating)
ARCH="$(dpkg --print-architecture)"
sudo install -d -m 0755 /etc/apt/keyrings
wget -qO- https://dl.google.com/linux/linux_signing_key.pub \
  | sudo gpg --dearmor -o /etc/apt/keyrings/google-linux.gpg
echo "deb [arch=${ARCH} signed-by=/etc/apt/keyrings/google-linux.gpg] http://dl.google.com/linux/chrome/deb/ stable main" \
  | sudo tee /etc/apt/sources.list.d/google-chrome.list >/dev/null

sudo apt-get update
sudo apt-get install -y google-chrome-stable
google-chrome --version

echo "[OK] Chrome installed and managed via apt."


11) NoMachine Remote Desktop
#!/usr/bin/env bash
# Install NoMachine on Ubuntu from a specific .deb URL
# Usage: save as install-nomachine.sh && chmod +x install-nomachine.sh && ./install-nomachine.sh

set -euo pipefail

URL="https://web9001.nomachine.com/download/9.1/Linux/nomachine_9.1.24_6_amd64.deb"
EXPECTED_MD5="0b4162766d6e12e80c7d53d361813e08"   # from NoMachine download page
DEB_NAME="$(basename "$URL")"

# 1) Sanity checks
ARCH="$(dpkg --print-architecture)"
if [[ "$ARCH" != "amd64" ]]; then
  echo "This package is for amd64, but your system reports: $ARCH"
  echo "Grab the correct build for your architecture."
  exit 1
fi

# 2) Download
mkdir -p "$HOME/Downloads"
cd "$HOME/Downloads"
echo "Downloading $DEB_NAME ..."
curl -fL --retry 3 -o "$DEB_NAME" "$URL"

# 3) Optional integrity check (MD5)
if command -v md5sum >/dev/null 2>&1; then
  ACTUAL_MD5="$(md5sum "$DEB_NAME" | awk '{print $1}')"
  if [[ "$ACTUAL_MD5" != "$EXPECTED_MD5" ]]; then
    echo "MD5 mismatch!"
    echo "Expected: $EXPECTED_MD5"
    echo "Actual:   $ACTUAL_MD5"
    echo "Aborting for safety."
    exit 1
  fi
  echo "MD5 OK."
fi

# 4) Install
echo "Installing NoMachine..."
sudo apt update
# Try the clean apt path first (handles deps automatically)
if ! sudo apt install -y "./$DEB_NAME"; then
  # Fallback: dpkg then fix deps
  sudo dpkg -i "./$DEB_NAME" || true
  sudo apt -f install -y
fi

# 5) Verify service
echo "Checking nxserver status..."
if sudo /usr/NX/bin/nxserver --status; then
  echo "NoMachine installed and running."
else
  echo "NoMachine installed, but service check failed."
  echo "Try: sudo /usr/NX/bin/nxserver --restart"
fi

# 6) Open firewall port if UFW is active
if command -v ufw >/dev/null 2>&1 && sudo ufw status | grep -q "Status: active"; then
  echo "UFW is active; allowing TCP 4000 (NX protocol)..."
  sudo ufw allow 4000/tcp || true
fi

# 7) Show how to connect
IP="$(hostname -I | awk '{print $1}')"
echo
echo "Done. From your client, connect to: ${IP}:4000"
echo "To manage the service:"
echo "  sudo /usr/NX/bin/nxserver --status|--start|--stop|--restart"

12) Docker Engine CLI
#!/usr/bin/env bash
set -euo pipefail

echo "[1/6] Pre-reqs"
sudo apt-get update -y
sudo apt-get install -y ca-certificates curl gnupg lsb-release

echo "[2/6] Remove legacy/conflicting packages (safe if absent)"
sudo apt-get remove -y docker docker.io docker-doc docker-compose podman-docker containerd runc || true

echo "[3/6] Prepare keyring"
sudo install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
sudo chmod a+r /etc/apt/keyrings/docker.gpg

echo "[4/6] Add Docker apt repo"
. /etc/os-release
case "${ID,,}" in
  ubuntu) repo_distro="ubuntu" ;;
  debian) repo_distro="debian" ;;
  *) echo "Unsupported distro: $ID" ; exit 1 ;;
esac
codename="${VERSION_CODENAME:-$(lsb_release -cs)}"
echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/${repo_distro} ${codename} stable" \
  | sudo tee /etc/apt/sources.list.d/docker.list >/dev/null

echo "[5/6] Install Docker Engine + CLI + Compose plugin"
sudo apt-get update -y
sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

echo "[6/6] Create docker group and add your user"
TARGET_USER="${SUDO_USER:-$USER}"
sudo groupadd -f docker
sudo usermod -aG docker "$TARGET_USER"

echo "[post] Enable and start the daemon"
sudo systemctl enable --now docker

cat <<'EOF'

[OK] Docker Engine installed.

- To use docker without sudo immediately:
    newgrp docker
  (or log out/in)

- Quick checks:
    docker --version
    docker compose version
    docker run --rm hello-world

EOF


13) Docker Desktop
#!/usr/bin/env bash
set -euo pipefail

TARGET_USER="${SUDO_USER:-$USER}"

echo "[0] Environment checks"
virt="$(systemd-detect-virt || true)"
if [[ "$virt" == "lxc" ]]; then
  echo "✗ LXC container detected: Docker Desktop is not supported here. Aborting."
  exit 2
fi
if [[ ! -e /dev/kvm ]]; then
  echo "✗ /dev/kvm not present: nested virtualization is unavailable. Aborting."
  echo "  (Enable nested KVM if you’re inside a Proxmox VM.)"
  exit 2
fi

echo "[1/5] Pre-reqs"
sudo apt-get update -y
sudo apt-get install -y ca-certificates curl lsb-release

echo "[2/5] Clean stale Desktop apt entries"
sudo rm -f /etc/apt/sources.list.d/docker-desktop.list /etc/apt/keyrings/docker-desktop.gpg || true

echo "[3/5] Download the .deb"
arch="$(dpkg --print-architecture)"
case "$arch" in
  amd64) DD_URL="https://desktop.docker.com/linux/main/amd64/docker-desktop-amd64.deb" ;;
  arm64) DD_URL="https://desktop.docker.com/linux/main/arm64/docker-desktop-arm64.deb" ;;
  *) echo "Unsupported arch: $arch" ; exit 1 ;;
esac

tmpdeb="$(mktemp /tmp/docker-desktop-XXXXXX.deb)"
if ! curl -fL -H "User-Agent: Mozilla/5.0" "$DD_URL" -o "$tmpdeb"; then
  if command -v wget >/dev/null; then
    wget -O "$tmpdeb" "$DD_URL"
  else
    echo "✗ Download failed."; exit 1
  fi
fi

echo "[4/5] Install the .deb"
sudo apt-get install -y "$tmpdeb"
rm -f "$tmpdeb"

echo "[5/5] Allow user access to KVM and start Desktop service"
sudo usermod -aG kvm "$TARGET_USER" || true
sudo loginctl enable-linger "$TARGET_USER" || true
sudo -u "$TARGET_USER" systemctl --user daemon-reload || true
sudo -u "$TARGET_USER" systemctl --user enable --now docker-desktop || true

cat <<'EOF'

[OK] Docker Desktop installed.

Notes:
- If the service didn’t start, log out/in (or reboot) and run:
    systemctl --user start docker-desktop
- Verify:
    docker --version
    docker compose version
- If you see KVM permission issues:
    groups
    # ensure your user shows 'kvm' (log out/in if just added)

EOF

14) Nginx Reverse Proxy
#!/usr/bin/env bash
# nginx-base-install.sh — Ubuntu 24.04+ base install only (no config)
set -euo pipefail

echo "[1/3] Update apt index…"
sudo apt-get update -y

echo "[2/3] Install Nginx…"
sudo apt-get install -y nginx

echo "[3/3] Enable & start service…"
sudo systemctl enable --now nginx

echo
nginx -v || true
systemctl --no-pager --full status nginx | sed -n '1,5p' || true
echo
echo "✅ Nginx installed and running. No configuration was changed."

15) Cloudflared Tunnel Daemon
#!/usr/bin/env bash
set -euo pipefail

# Cloudflare apt repo (Ubuntu 24.04 "noble")
sudo mkdir -p --mode=0755 /usr/share/keyrings
curl -fsSL https://pkg.cloudflare.com/cloudflare-main.gpg | sudo tee /usr/share/keyrings/cloudflare-main.gpg >/dev/null
echo 'deb [signed-by=/usr/share/keyrings/cloudflare-main.gpg] https://pkg.cloudflare.com/cloudflared noble main' \
  | sudo tee /etc/apt/sources.list.d/cloudflared.list

sudo apt update
sudo apt install -y cloudflared

cloudflared --version
echo "[OK] cloudflared installed (apt-managed)."


16) Flatpak / Snap App Managers
#!/usr/bin/env bash
set -euo pipefail

echo "[1/4] Flatpak CLI…"
sudo apt update
sudo apt install -y flatpak

# Optional: GUI integration (GNOME Software)
if dpkg -s gnome-software >/dev/null 2>&1; then
  sudo apt install -y gnome-software-plugin-flatpak
fi

echo "[2/4] Add Flathub (system-wide)…"
sudo flatpak remote-add --if-not-exists flathub \
  https://dl.flathub.org/repo/flathub.flatpakrepo

echo "[3/4] Snap (ensure snapd exists)…"
if ! command -v snap >/dev/null 2>&1; then
  sudo apt install -y snapd
  sudo systemctl enable --now snapd.socket || true
fi

# Optional: update base snap(s); harmless if already present
sudo snap refresh || true

echo "[4/4] Done. If you use a desktop, log out/in once for Flatpak GUI integration."
echo "[OK] Optional package managers configured."

17) Flatpak / Snap Applications
#!/usr/bin/env bash
set -euo pipefail

# Install commonly used Flatpak applications
# Uncomment or modify as needed for your workflow

# Media
# flatpak install -y flathub com.spotify.Client
# flatpak install -y flathub org.videolan.VLC

# Graphics
# flatpak install -y flathub org.gimp.GIMP
# flatpak install -y flathub org.inkscape.Inkscape

# Communication & Security
# Discord (Flatpak - verified by Discord on Flathub)
# flatpak install -y flathub com.discordapp.Discord

# Bitwarden (Snap - official from Bitwarden)
# sudo snap install bitwarden
# sudo snap connect bitwarden:password-manager-service

echo "[OK] Flatpak applications installed (or none selected)."

18) JetBrains Toolbox
#!/usr/bin/env bash
# jetbrains-toolbox-install.sh — Ubuntu 24.04+ (installs latest Toolbox to your user)
set -euo pipefail

ARCH="$(uname -m)"
case "$ARCH" in
  x86_64|amd64)  JB_ARCH_KEY="linux" ;;
  aarch64|arm64) JB_ARCH_KEY="linuxArm64" ;;
  *) echo "Unsupported arch: $ARCH"; exit 1 ;;
esac

TMP="$(mktemp -d)"
cleanup(){ rm -rf "$TMP"; }
trap cleanup EXIT

echo "[1/4] Resolving latest Toolbox download URL for $JB_ARCH_KEY…"
URL="$(python3 - <<'PY'
import json, sys, urllib.request
u="https://data.services.jetbrains.com/products/releases?code=TBA&latest=true&type=release"
with urllib.request.urlopen(u) as r:
    j=json.load(r)
d=j["TBA"][0]["downloads"]
print(d.get("linuxArm64", d["linux"])["link"])
PY
)"
[ -n "$URL" ] || { echo "Could not resolve download URL."; exit 2; }

echo "    -> $URL"
cd "$TMP"

echo "[2/4] Downloading…"
curl -fsSLo toolbox.tar.gz "$URL"

echo "[3/4] Extracting…"
tar -xzf toolbox.tar.gz
DIR="$(find . -maxdepth 1 -type d -name 'jetbrains-toolbox*' | head -n1)"
[ -n "$DIR" ] || { echo "Extract failed."; exit 3; }

echo "[4/4] Launching Toolbox once to self-install (~/.local/share/JetBrains/Toolbox)…"
chmod +x "$DIR/jetbrains-toolbox"
# Launch in background; it will place binaries and desktop files under your home.
setsid "$DIR/jetbrains-toolbox" >/dev/null 2>&1 & disown || true

echo
echo "✅ Toolbox started. It installs itself under:"
echo "   ~/.local/share/JetBrains/Toolbox/bin"
echo "It also adds a desktop entry and autostart on first run."
echo
echo "Open it from your app menu (JetBrains Toolbox) to install IDEs."

19) Chezmoi (base install)
#!/usr/bin/env bash
# Chezmoi — Install (official installer to ~/.local/bin; no fallbacks)
set -euo pipefail

# Run as your normal user (not root)
if [[ $EUID -eq 0 ]]; then
  echo "Please run as a normal user, not root." >&2
  exit 1
fi

# Ensure ~/.local/bin exists and is on PATH (now and for future shells)
mkdir -p "$HOME/.local/bin"
ensure_path_line='export PATH="$HOME/.local/bin:$PATH"'
grep -qF "$ensure_path_line" "$HOME/.bashrc" || echo "$ensure_path_line" >> "$HOME/.bashrc"
[[ -f "$HOME/.zshrc" ]] && (grep -qF "$ensure_path_line" "$HOME/.zshrc" || echo "$ensure_path_line" >> "$HOME/.zshrc")
export PATH="$HOME/.local/bin:$PATH"

# Install chezmoi (assumes curl is present and the first attempt works)
sh -c "$(curl -fsLS get.chezmoi.io)" -- -b "$HOME/.local/bin"

# Verify
chezmoi --version | head -n1
echo "✅ Chezmoi installed to $HOME/.local/bin (open a new shell or 'source ~/.bashrc' to refresh PATH)."


20) Chezmoi (apply dotfiles)
#!/usr/bin/env bash
# Chezmoi — Setup & Apply (simple)
set -euo pipefail

# Config (override with DOTFILES_REPO env var if you want SSH)
DOTFILES_REPO="${DOTFILES_REPO:-https://github.com/Beta-Techno/dotfiles.git}"

# Ensure chezmoi is on PATH if you just installed to ~/.local/bin
export PATH="$HOME/.local/bin:$PATH"

# Sanity
[[ $EUID -ne 0 ]] || { echo "Run as your normal user, not root." >&2; exit 1; }
command -v chezmoi >/dev/null || { echo "chezmoi not found (run install block first)"; exit 1; }

# If a chezmoi git source already exists, update it; otherwise init from repo
SRC="$(chezmoi source-path)"
if [[ -d "$SRC/.git" ]]; then
  chezmoi git pull --ff-only
else
  chezmoi init "$DOTFILES_REPO"
fi

# Apply dotfiles
chezmoi apply

echo "✅ Dotfiles applied."

21) JetBrainsMono Nerd Font
#!/usr/bin/env bash
set -euo pipefail

FONT_DIR="$HOME/.local/share/fonts"
mkdir -p "$FONT_DIR"
cd "$FONT_DIR"

curl -fLO https://github.com/ryanoasis/nerd-fonts/releases/latest/download/JetBrainsMono.zip
unzip -o JetBrainsMono.zip
rm JetBrainsMono.zip

# Refresh font cache for the user
fc-cache -fv

echo "✅ JetBrainsMono Nerd Font installed under $FONT_DIR."

22) Terminal Enhancement
#!/usr/bin/env bash
set -euo pipefail

# GNOME Tweaks & extensions
sudo apt install -y gnome-tweaks gnome-shell-extensions

# Terminal emulators
sudo apt install -y tilix

# Enhanced utilities
sudo apt install -y zsh fd-find bat tree xclip

# Oh My Zsh
sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended

# Make utilities available under familiar names
sudo update-alternatives --install /usr/local/bin/bat batcat /usr/bin/batcat 10 || true
sudo update-alternatives --install /usr/local/bin/fd fdfind /usr/bin/fdfind 10 || true

echo "[OK] Terminal environment enhanced."

23) Cleanup & Final Steps
#!/usr/bin/env bash
set -euo pipefail

# Fix any missing dependencies
sudo apt -f install -y

# Clean up
sudo apt autoremove -y
rm -f /tmp/*.deb /tmp/*.tar.gz

echo "[OK] Cleanup complete. Reboot recommended if kernel/drivers changed."
echo "After reboot, run: source ~/.bashrc && source ~/.zshrc"

You said:
before returning to nix and commiting completly, i wanted to ensure I could have some IaC deployment / setup without nix

i dont know if i should dig into ansible, stay pure bash or use a fancy bash or even a specific language with possible libs

nix is where the system will be built completely 
as you see currently for ubuntu I just have a template to set up being able to easily host docker containers
i have another repo harbor dedicated to orchestrating the containers once the machine is configured

how would you proceed? what is your will
the goal is not to recreate my flake here at all
just the simple blank canvas machine so i can deploy legacy systems without having manual setup
tell me what is wrong in my thought process and correct to what you think is right
You said:
so to give more context to my insight i see this as backup from nix everything and onboarding for those not comfortable or with existing setups not wanting to switch or for quick dev enviorments. 

people without proxmox and many nix-os vms can set up a server and workstation 2 in one, and from harbor deploy any containerized part of our system as they prefer
traefik + cloudflare + dockge makes the gui unecessary but again for those who have lived in the classic world this was for them

not optimized for deployment, that is nix
tell me i am wrong

i just heard so much shit about ansible
thats why i was pushed to nix
but i do what you tell me is best
i would still like my nice ux if possible with ansible deployment
tell me what is truly best
